
#include "texture.h"

/*
#ifndef INT64_C
#define INT64_C(c) (c ## LL)
#define UINT64_C(c) (c ## ULL)
#endif
#include <avcodec.h>
#include <avformat.h>
#include <avformat.h>
*/

namespace SCore
{

#if 0
    textureVideo::textureVideo( const char *filename, textureFiltering sf )
    {
        int             numBytes;
        uint8_t         *buffer;
        AVFormatContext *pFormatCtx;
        AVCodecContext  *pCodecCtx;
        AVCodec         *pCodec;
        AVFrame         *pFrame;
        AVFrame         *pFrameRGB;

        av_register_all();

        // Open video file
        if( avformat_open_input( &pFormatCtx, filename, NULL, NULL ) != 0 )
            return; // Couldn't open file

        // Retrieve stream information
        if( avformat_find_stream_info( pFormatCtx, NULL ) < 0 )
            return; // Couldn't find stream information

        // Dump information about file onto standard error
        //dump_format(pFormatCtx, 0, filename, false);

        // Find the first video stream
        int videoStream = -1;

        for(int i=0; i<int(pFormatCtx->nb_streams); i++)
        {
            int codty = static_cast<int>( pFormatCtx->streams[i]->codec->codec_id );

            if(codty > CODEC_ID_NONE && codty < CODEC_ID_FIRST_AUDIO)
            {
                videoStream=i;
                break;
            }
        }

        if (videoStream == -1)
            return; // Didn't find a video stream

        // Get a pointer to the codec context for the video stream
        pCodecCtx = pFormatCtx->streams[videoStream]->codec;

        // Find the decoder for the video stream
        pCodec = avcodec_find_decoder( pCodecCtx->codec_id );
        if( pCodec == NULL )
            return; // Codec not found

        // Inform the codec that we can handle truncated bitstreams -- i.e.,
        // bitstreams where frame boundaries can fall in the middle of packets
        if(pCodec->capabilities & CODEC_CAP_TRUNCATED)
            pCodecCtx->flags|=CODEC_FLAG_TRUNCATED;

        // Open codec
        if(avcodec_open2(pCodecCtx, pCodec, NULL)<0)
            return; // Could not open codec

        // Hack to correct wrong frame rates that seem to be generated by some
        // codecs
        /*
        if(pCodecCtx->frame_rate>1000 && pCodecCtx->frame_rate_base==1)
            pCodecCtx->frame_rate_base=1000;
        */

        // Allocate video frame
        pFrame=avcodec_alloc_frame();

        // Allocate an AVFrame structure
        pFrameRGB=avcodec_alloc_frame();
        if(pFrameRGB==NULL)
            return;

        // Determine required buffer size and allocate buffer
        numBytes = avpicture_get_size(PIX_FMT_RGB24, pCodecCtx->width, pCodecCtx->height);
        buffer = new uint8_t[numBytes];

        // Assign appropriate parts of buffer to image planes in pFrameRGB
        avpicture_fill((AVPicture *)pFrameRGB, buffer, PIX_FMT_RGB24,
            pCodecCtx->width, pCodecCtx->height);
    }
#else
    textureVideo::textureVideo( const char *filename, textureFiltering sf )
    {
	}
#endif

    textureVideo::~textureVideo()
    {

    }

}
